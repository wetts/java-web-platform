1>  性能考虑，数组是首选
	对基本类型进行求和计算时，数组的效率是集合的10倍
2>  若有必要，使用变长数组
3>  警惕数组的浅拷贝
	通过copyOf方法产生的数组是一个浅拷贝，这与序列化的浅拷贝完全相同
4>  在明确的场景下，为集合指定初始容量
5>  多种最值算法，适时选择
	最值计算时使用集合最简单，使用数字性能最优
6>  避开基本类型数组转换列表陷阱
	asList方法输入的是一个泛型变长参数，基本类型是不能泛型化的，也就是说8个基本类型不能作为泛型数组
7>  asList方法产生的List对象不可更改
8>  不同的列表选择不同的遍历方法
9>  频繁插入和删除时使用LinkedList
10> 列表相等只需关心元素数据
	列表只是一个容器，只要是同一个类型的容器（如List），不用关心容器的细节差别（如ArrayList和LinkedList），只要确定所有的元素数据相等，那这两个列表就是相等的。
11> 子列表只是原列表的一个视图
12> 推荐使用subList处理局部列表
13> 生成子列表后不要在操作原列表
14> 使用Comparator进行排序
	Comparable接口可以作为实现类的默认排序法
	Comparator接口则是一个类的扩展排序工具
15> 不推荐使用binarySearch对列表进行索引
16> 集合中的元素必须做到conpareTo和equals同步
17> 集合运算时使用更优雅的方式
18> 使用shuffle打乱列表
19> 减少HashMap中元素的数量
	HashMap：
		在插入键值对时，会做长度校验，如果大于或等于阈值（threshold变量），则数组长度增大一倍，默认是当前长度与加载因子的乘积。
		默认的加载因子是0.75，也就是说只要HashMap的size大于数组长度为0.75倍时，就开始扩容
	ArrayList：
		在小于数组长度的时候才会扩容到1.5倍
20> 集合中的哈希码不要重复
	哈希运算存在着哈希冲突问题，即对于一个固定的哈希算法f(k)，允许出现f(k1)=f(k2)，但k1!=k2的情况，也就是说两个不同的Entry，可能产生相同的哈希码。
	HashMap是如何处理这种问题的呢？
		通过链表，每个键值都是一个Entry，其中每个Entry都有一个next变量，也就是说它会指向下一个键值对。
21> 多线程使用Vector或HashTable
22> 非稳定排序推荐使用List
	TreeSet，该类实现了类默认排序为升序的Set集合
