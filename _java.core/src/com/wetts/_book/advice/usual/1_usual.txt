1>  不要在常量和变量中出现易混淆的字母
2>  莫让常量变成变量
3>  三元操作符的类型务必一致
	三元操作符类型的转换规则：
		若两个操作数不可转换，则不做转换，返回值为Object类型
		若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long，long转换为fload
		若两个操作数中有一个是S，另外一个表达式。且其类型表示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型
		若两个操作数都是直接量数字，则返回值类型为范围较大者
4>  避免带有变长参数的方法重载
5>  别让null值和空值威胁到变长方法
6>  覆写变长方法也循规蹈矩
	覆写必须满足的条件；
		重写方法不能缩小访问权限
		参数列表必须与被重写方法相同
		返回类型必须与被重写方法的相同或是其子类
		重写方法不能抛出新的异常
7>  警惕自增的陷阱
	Java对自增是这样处理的：
		首先把count的值（注意是值，不是引用）拷贝到一个临时变量区，
		然后对count变量加1
		最后返回临时变量区的值
	C++中“count=count++”与“count++”是等效的，而PHP中则保持与Java相同的处理方式
8>  不要让旧语法困扰你
	saveDefault:save(fee);
		“:”在C语言中是goto，在Java中保留，但是没有作用，上面语句仅仅执行save(fee)方法
9>  少用静态导入
	静态导入的两个规则：
		不使用*通配符，除非是导入静态常量类
		方法名是具有明确、清晰表象意义的工具类
10> 不要在本类中覆盖静态导入的变量和方法
11> 养成良好习惯，显式声明UID
12> 避免用序列化类在构造函数中为不变量赋值
	反序列化的时候构造函数不会执行
13> 避免为final变量复杂赋值
	反序列化时final变量在以下情况不会被重新赋值：
		通过构造函数为final变量赋值
		通过方法返回值为final变量赋值
		final修饰的属性不是基本类型
14> 使用序列化类的私有方法巧妙解决部分属性持久化问题
	Java调用ObjectOutputStream类把一个对象转换成流数据时，会通过反射（Reflection）检查被序列化的类是否有writeObject方法，
	并且检查是否符合私有、无返回值的特性。若有，则会委托该方法进行对象序列化，若没有，则由ObjectOutputStream按照默认规则继续序列化。
	同样，在从流数据恢复成实例对象时，也会检查是否有一个私有的readObject方法，如果有，则通过该方法读取属性值。
15> break万万不能忘
16> 易变业务使用脚本语言编写
17> 慎用动态编译
18> 避免instanceof非预期结果
	若左操作数是null，结果就是直接返回false
	instanceof操作符的左右操作数必须有继承关系或者实现关系，否则编译会失败
19> 断言绝对不是鸡肋
	assert <布尔表达式> : <错误信息>
	assert有以下两个特性：
		assert默认是不启用的
		assert抛出的异常AssertionError是继承自Error的
	以下两种情况不要使用断言：
		在对外公开的方法中
		在执行逻辑代码的情况下
	按照正常执行逻辑不可能到达的代码区域可以放置assert，具体分为三种情况；
		在私有方法中放置assert作为输入参数的校验
		流程控制中不可能达到的区域
		建立程序探针
20> 不要只替换一个类
	对于final修饰的基本类型和String类型，编译器会认为它是稳定态（Immutable Status），所以在编译时就直接把值编译到字节码中了，避免了在运行期引用（Run-time Reference），以提高代码的执行效率。
