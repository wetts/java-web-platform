1>  在接口中不要存在实现代码
2>  静态变量一定要先声明后赋值
3>  不要覆写静态方法
	在子类中构建与父类相同的方法名、输入参数、输出参数、访问权限（权限可扩大）、并且父类、子类都是静态方法，此种行为叫做隐藏（Hide），它与覆写有两点不同：
		表现形式不同。隐藏用于静态方法，覆写用于非静态方法。在代码上的表现是：@Override注解可以用于覆写，不能用于隐藏
		职责不同。隐藏的目的是为了抛弃父类的静态方法，重现子类方法，
4>  构造函数尽量简化
5>  避免在构造函数中初始化其他类
6>  使用构造代码块精炼程序
	Java中一共有四种类型的代码块：
		普通代码块
		静态代码块
		同步代码块
		构造代码块
7>  构造代码块会想你所想
	Java会把构造代码块插入到没有this方法的构造函数中，而调用其他构造函数的则不插入，确保每个构造函数只执行一次构造代码块
8>  使用静态内部类提高封装性
	好处：
		提高封装性
		提高代码的可读性
		形似内部，神似外部
	静态内部类与普通内部类的区别：
		静态内部类不持有外部类的引用
		静态内部类不依赖外部类
		普通内部类不能声明static的方法和变量
9>  使用匿名类的构造函数
	List<Object> l1 = new ArrayList<Object>();
	List<Object> l2 = new ArrayList<Object>(){};
		l2代表的是一个匿名类的声明和赋值
		代码类似于：
			class Sub extends ArrayList {}
	List<Object> l3 = new ArrayList<Object>(){{}};
		代码类似于：
			class Sub extends ArrayList {
				{}
			}
10> 匿名类的构造函数很特殊
11> 让多重继承成为现实
12> 让工具类不可实例化
13> 避免对象的浅拷贝
	基本类型
		如果变量是基本类型，则拷贝其值
	对象
		如果变量是一个实例对象，则拷贝地址引用
	String字符串
		这个比较特殊，拷贝的也是一个地址，是个引用，但是在修改时，它会从字符串池（String Pool）中重新生成新的字符串，原字符串对象保持不变，在此我们可以认为String是一个基本类型
14> 推荐使用序列化实现对象的拷贝
15> 覆写equals方法时不要识别不出自己
16> equals应该考虑null值情景
17> 在equals中使用getClass进行类型判断
18> 覆写equals方法必须覆写hashcode方法
	HashMap的底层处理机制是以数组的方式保存Map条目（Map Entry）的，这其中的关键是这个数组下标的处理机制：
		依据传入元素hashCode方法的返回值决定其数组的下标，如果该数组位置上已经有了Map条目，且与传入的键值相等则不处理，若不想等则覆盖；如果数组位置没有条目，则插入，并加入到Map条目的链表中
	同理，检查键是否存在也是根据哈希码确定位置，然后遍历查找键值的
19> 推荐覆写toString方法
20> 使用package-info类为包服务
	作用：
		声明友好类和包内访问常量
		为在报上标注注解提供便利
		提供包的整体注解说明
21> 不要主动进行垃圾回收
