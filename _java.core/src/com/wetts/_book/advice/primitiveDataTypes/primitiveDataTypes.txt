1>  用偶判断，不用奇判断
2>  用整数类型处理货币
	在计算机中浮点数有可能是不准确的，要解决此问题有两种方法：
		使用BigDecimal
		使用整型
			把参与运算的值扩大100倍，并转成整型，然后在展现时再缩小100倍
3>  不要让类型默默转换
	Java是先运算然后再进行类型转换的
		long l = 300000000 * 8 * 60，先是三者相乘，然后再转换成long型
4>  边界问题
5>  四舍五入
6>  提防包装类型的null值
7>  谨慎包装类型的大小比较
8>  优先使用整型池
	valueOf
		通过包装类的valueOf生成包装实例可以显著提高空间和时间性能
9>  优先选择基本类型
10> 不要随便设置随机种子
	计算机不同输出的随机数不同，但是有一点是相同的：在同一台机器上，甭管运行多少次，所打印的随机数都是相同的，也就是说第一次运行和第二次运行，打印出的随机数顺序永远相同
	那是因为产生随机数的种子固定了，在Java中，随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则：
		种子不同，产生不同的随机数
		种子相同，即使实例不同也产生相同的随机数
	默认种子是System.nanoTime()的返回值（JDK1.5版本以前默认种子是System.currentTimeMilles()的返回值）
